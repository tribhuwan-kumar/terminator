/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface Bounds {
  x: number
  y: number
  width: number
  height: number
}
export interface Coordinates {
  x: number
  y: number
}
export interface ClickResult {
  method: string
  coordinates?: Coordinates
  details: string
}
export interface CommandOutput {
  exitStatus?: number
  stdout: string
  stderr: string
}
export interface ScreenshotResult {
  width: number
  height: number
  imageData: Array<number>
}
export interface UIElementAttributes {
  role: string
  name?: string
  label?: string
  value?: string
  description?: string
  properties: Record<string, string | undefined | null>
  isKeyboardFocusable?: boolean
}
export interface ExploredElementDetail {
  role: string
  name?: string
  id?: string
  bounds?: Bounds
  value?: string
  description?: string
  text?: string
  parentId?: string
  childrenIds: Array<string>
  suggestedSelector: string
}
export interface ExploreResponse {
  parent: Element
  children: Array<ExploredElementDetail>
}
/** Main entry point for desktop automation. */
export declare class Desktop {
  /**
   * Create a new Desktop automation instance with configurable options.
   *
   * @param {boolean} [useBackgroundApps=false] - Enable background apps support.
   * @param {boolean} [activateApp=false] - Enable app activation support.
   * @param {string} [logLevel] - Logging level (e.g., 'info', 'debug', 'warn', 'error').
   * @returns {Desktop} A new Desktop automation instance.
   */
  constructor(useBackgroundApps?: boolean | undefined | null, activateApp?: boolean | undefined | null, logLevel?: string | undefined | null)
  /**
   * Get the root UI element of the desktop.
   *
   * @returns {Element} The root UI element.
   */
  root(): Element
  /**
   * Get a list of all running applications.
   *
   * @returns {Array<Element>} List of application UI elements.
   */
  applications(): Array<Element>
  /**
   * Get a running application by name.
   *
   * @param {string} name - The name of the application to find.
   * @returns {Element} The application UI element.
   */
  application(name: string): Element
  /**
   * Open an application by name.
   *
   * @param {string} name - The name of the application to open.
   */
  openApplication(name: string): Element
  /**
   * Activate an application by name.
   *
   * @param {string} name - The name of the application to activate.
   */
  activateApplication(name: string): void
  /**
   * (async) Capture a screenshot of the primary monitor.
   *
   * @returns {Promise<ScreenshotResult>} The screenshot data.
   */
  captureScreen(): Promise<ScreenshotResult>
  /**
   * (async) Run a shell command.
   *
   * @param {string} [windowsCommand] - Command to run on Windows.
   * @param {string} [unixCommand] - Command to run on Unix.
   * @returns {Promise<CommandOutput>} The command output.
   */
  runCommand(windowsCommand?: string | undefined | null, unixCommand?: string | undefined | null): Promise<CommandOutput>
  /**
   * (async) Capture a screenshot of a specific monitor.
   *
   * @param {string} name - The name of the monitor to capture.
   * @returns {Promise<ScreenshotResult>} The screenshot data.
   */
  captureMonitorByName(name: string): Promise<ScreenshotResult>
  /**
   * (async) Perform OCR on an image file.
   *
   * @param {string} imagePath - Path to the image file.
   * @returns {Promise<string>} The extracted text.
   */
  ocrImagePath(imagePath: string): Promise<string>
  /**
   * (async) Perform OCR on a screenshot.
   *
   * @param {ScreenshotResult} screenshot - The screenshot to process.
   * @returns {Promise<string>} The extracted text.
   */
  ocrScreenshot(screenshot: ScreenshotResult): Promise<string>
  /**
   * (async) Find a window by criteria.
   *
   * @param {string} [titleContains] - Text that should be in the window title.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<Element>} The found window element.
   */
  findWindowByCriteria(titleContains?: string | undefined | null, timeoutMs?: number | undefined | null): Promise<Element>
  /**
   * (async) Get the currently focused browser window.
   *
   * @returns {Promise<Element>} The current browser window element.
   */
  getCurrentBrowserWindow(): Promise<Element>
  /**
   * Create a locator for finding UI elements.
   *
   * @param {string} selector - The selector string to find elements.
   * @returns {Locator} A locator for finding elements.
   */
  locator(selector: string): Locator
  /**
   * (async) Get the currently focused window.
   *
   * @returns {Promise<Element>} The current window element.
   */
  getCurrentWindow(): Promise<Element>
  /**
   * (async) Get the currently focused application.
   *
   * @returns {Promise<Element>} The current application element.
   */
  getCurrentApplication(): Promise<Element>
  /**
   * Get the currently focused element.
   *
   * @returns {Element} The focused element.
   */
  focusedElement(): Element
  /**
   * Open a URL in a browser.
   *
   * @param {string} url - The URL to open.
   * @param {string} [browser] - The browser to use.
   */
  openUrl(url: string, browser?: string | undefined | null): void
  /**
   * Open a file with its default application.
   *
   * @param {string} filePath - Path to the file to open.
   */
  openFile(filePath: string): void
  /**
   * Activate a browser window by title.
   *
   * @param {string} title - The window title to match.
   */
  activateBrowserWindowByTitle(title: string): void
}
/** A UI element in the accessibility tree. */
export declare class Element {
  /**
   * Get the element's ID.
   *
   * @returns {string | null} The element's ID, if available.
   */
  id(): string | null
  /**
   * Get the element's role.
   *
   * @returns {string} The element's role (e.g., "button", "textfield").
   */
  role(): string
  /**
   * Get all attributes of the element.
   *
   * @returns {UIElementAttributes} The element's attributes.
   */
  attributes(): UIElementAttributes
  /**
   * Get the element's name.
   *
   * @returns {string | null} The element's name, if available.
   */
  name(): string | null
  /**
   * Get children of this element.
   *
   * @returns {Array<Element>} List of child elements.
   */
  children(): Array<Element>
  /**
   * Get the parent element.
   *
   * @returns {Element | null} The parent element, if available.
   */
  parent(): Element | null
  /**
   * Get element bounds.
   *
   * @returns {Bounds} The element's bounds (x, y, width, height).
   */
  bounds(): Bounds
  /**
   * Click on this element.
   *
   * @returns {ClickResult} Result of the click operation.
   */
  click(): ClickResult
  /**
   * Double click on this element.
   *
   * @returns {ClickResult} Result of the click operation.
   */
  doubleClick(): ClickResult
  /** Right click on this element. */
  rightClick(): void
  /** Hover over this element. */
  hover(): void
  /**
   * Check if element is visible.
   *
   * @returns {boolean} True if the element is visible.
   */
  isVisible(): boolean
  /**
   * Check if element is enabled.
   *
   * @returns {boolean} True if the element is enabled.
   */
  isEnabled(): boolean
  /** Focus this element. */
  focus(): void
  /**
   * Get text content of this element.
   *
   * @param {number} [maxDepth] - Maximum depth to search for text.
   * @returns {string} The element's text content.
   */
  text(maxDepth?: number | undefined | null): string
  /**
   * Type text into this element.
   *
   * @param {string} text - The text to type.
   * @param {boolean} [useClipboard] - Whether to use clipboard for pasting.
   */
  typeText(text: string, useClipboard?: boolean | undefined | null): void
  /**
   * Press a key while this element is focused.
   *
   * @param {string} key - The key to press.
   */
  pressKey(key: string): void
  /**
   * Set value of this element.
   *
   * @param {string} value - The value to set.
   */
  setValue(value: string): void
  /**
   * Perform a named action on this element.
   *
   * @param {string} action - The action to perform.
   */
  performAction(action: string): void
  /**
   * Scroll the element in a given direction.
   *
   * @param {string} direction - The direction to scroll.
   * @param {number} amount - The amount to scroll.
   */
  scroll(direction: string, amount: number): void
  /** Activate the window containing this element. */
  activateWindow(): void
  /**
   * Check if element is focused.
   *
   * @returns {boolean} True if the element is focused.
   */
  isFocused(): boolean
  /**
   * Check if element is keyboard focusable.
   *
   * @returns {boolean} True if the element can receive keyboard focus.
   */
  isKeyboardFocusable(): boolean
  /**
   * Drag mouse from start to end coordinates.
   *
   * @param {number} startX - Starting X coordinate.
   * @param {number} startY - Starting Y coordinate.
   * @param {number} endX - Ending X coordinate.
   * @param {number} endY - Ending Y coordinate.
   */
  mouseDrag(startX: number, startY: number, endX: number, endY: number): void
  /**
   * Press and hold mouse at coordinates.
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   */
  mouseClickAndHold(x: number, y: number): void
  /**
   * Move mouse to coordinates.
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   */
  mouseMove(x: number, y: number): void
  /** Release mouse button. */
  mouseRelease(): void
  /**
   * Create a locator from this element.
   *
   * @param {string} selector - The selector string.
   * @returns {Locator} A new locator for finding elements.
   */
  locator(selector: string): Locator
  /**
   * Get the containing application element.
   *
   * @returns {Element | null} The containing application element, if available.
   */
  application(): Element | null
  /**
   * Get the containing window element.
   *
   * @returns {Element | null} The containing window element, if available.
   */
  window(): Element | null
  /**
   * Explore this element and its direct children.
   *
   * @returns {ExploreResponse} Details about the element and its children.
   */
  explore(): ExploreResponse
  /**
   * Highlights the element with a colored border.
   *
   * @param {number} [color] - Optional BGR color code (32-bit integer). Default: 0x0000FF (red)
   * @param {number} [durationMs] - Optional duration in milliseconds.
   * @returns {void}
   */
  highlight(color?: number | undefined | null, durationMs?: number | undefined | null): void
}
/** Locator for finding UI elements by selector. */
export declare class Locator {
  /**
   * (async) Get the first matching element.
   *
   * @returns {Promise<Element>} The first matching element.
   */
  first(): Promise<Element>
  /**
   * (async) Get all matching elements.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @param {number} [depth] - Maximum depth to search.
   * @returns {Promise<Array<Element>>} List of matching elements.
   */
  all(timeoutMs?: number | undefined | null, depth?: number | undefined | null): Promise<Array<Element>>
  /**
   * (async) Wait for the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<Element>} The first matching element.
   */
  wait(timeoutMs?: number | undefined | null): Promise<Element>
  /**
   * Set a default timeout for this locator.
   *
   * @param {number} timeoutMs - Timeout in milliseconds.
   * @returns {Locator} A new locator with the specified timeout.
   */
  timeout(timeoutMs: number): Locator
  /**
   * Set the root element for this locator.
   *
   * @param {Element} element - The root element.
   * @returns {Locator} A new locator with the specified root element.
   */
  within(element: Element): Locator
  /**
   * Chain another selector.
   *
   * @param {string} selector - The selector string.
   * @returns {Locator} A new locator with the chained selector.
   */
  locator(selector: string): Locator
  /**
   * (async) Click on the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<ClickResult>} Result of the click operation.
   */
  click(timeoutMs?: number | undefined | null): Promise<ClickResult>
  /**
   * (async) Type text into the first matching element.
   *
   * @param {string} text - The text to type.
   * @param {boolean} [useClipboard] - Whether to use clipboard for pasting.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  typeText(text: string, useClipboard?: boolean | undefined | null, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Press a key on the first matching element.
   *
   * @param {string} key - The key to press.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  pressKey(key: string, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Get text from the first matching element.
   *
   * @param {number} [maxDepth] - Maximum depth to search for text.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<string>} The element's text content.
   */
  text(maxDepth?: number | undefined | null, timeoutMs?: number | undefined | null): Promise<string>
  /**
   * (async) Get attributes from the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<UIElementAttributes>} The element's attributes.
   */
  attributes(timeoutMs?: number | undefined | null): Promise<UIElementAttributes>
  /**
   * (async) Get bounds from the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<Bounds>} The element's bounds.
   */
  bounds(timeoutMs?: number | undefined | null): Promise<Bounds>
  /**
   * (async) Check if the element is visible.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<boolean>} True if the element is visible.
   */
  isVisible(timeoutMs?: number | undefined | null): Promise<boolean>
  /**
   * (async) Wait for the element to be enabled.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<Element>} The enabled element.
   */
  expectEnabled(timeoutMs?: number | undefined | null): Promise<Element>
  /**
   * (async) Wait for the element to be visible.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<Element>} The visible element.
   */
  expectVisible(timeoutMs?: number | undefined | null): Promise<Element>
  /**
   * (async) Wait for the element's text to equal the expected text.
   *
   * @param {string} expectedText - The expected text.
   * @param {number} [maxDepth] - Maximum depth to search for text.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<Element>} The element with matching text.
   */
  expectTextEquals(expectedText: string, maxDepth?: number | undefined | null, timeoutMs?: number | undefined | null): Promise<Element>
  /**
   * (async) Double click on the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<ClickResult>} Result of the click operation.
   */
  doubleClick(timeoutMs?: number | undefined | null): Promise<ClickResult>
  /**
   * (async) Right click on the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  rightClick(timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Hover over the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  hover(timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Explore the first matching element and its direct children.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<ExploreResponse>} Details about the element and its children.
   */
  explore(timeoutMs?: number | undefined | null): Promise<ExploreResponse>
  /**
   * (async) Get the id of the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<?string>} The element's id, or null if not present.
   */
  id(timeoutMs?: number | undefined | null): Promise<string | null>
  /**
   * (async) Get the role of the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<string>} The element's role.
   */
  role(timeoutMs?: number | undefined | null): Promise<string>
  /**
   * (async) Get the children of the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<Array<Element>>} The element's children.
   */
  children(timeoutMs?: number | undefined | null): Promise<Array<Element>>
  /**
   * (async) Get the parent of the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<?Element>} The element's parent, or null if not present.
   */
  parent(timeoutMs?: number | undefined | null): Promise<Element | null>
  /**
   * (async) Set value of the first matching element.
   *
   * @param {string} value - The value to set.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  setValue(value: string, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Check if the first matching element is focused.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<boolean>} True if the element is focused.
   */
  isFocused(timeoutMs?: number | undefined | null): Promise<boolean>
  /**
   * (async) Perform a named action on the first matching element.
   *
   * @param {string} action - The action name.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  performAction(action: string, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Scroll the first matching element in a given direction.
   *
   * @param {string} direction - The scroll direction (e.g., "up", "down").
   * @param {number} amount - The amount to scroll.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  scroll(direction: string, amount: number, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Activate the window containing the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  activateWindow(timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Get the name of the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<?string>} The element's name, or null if not present.
   */
  name(timeoutMs?: number | undefined | null): Promise<string | null>
  /**
   * (async) Check if the first matching element is keyboard focusable.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<boolean>} True if the element is keyboard focusable.
   */
  isKeyboardFocusable(timeoutMs?: number | undefined | null): Promise<boolean>
  /**
   * (async) Drag mouse from start to end coordinates on the first matching element.
   *
   * @param {number} startX - Starting x coordinate.
   * @param {number} startY - Starting y coordinate.
   * @param {number} endX - Ending x coordinate.
   * @param {number} endY - Ending y coordinate.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  mouseDrag(startX: number, startY: number, endX: number, endY: number, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Press and hold mouse at (x, y) on the first matching element.
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  mouseClickAndHold(x: number, y: number, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Move mouse to (x, y) on the first matching element.
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  mouseMove(x: number, y: number, timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Release mouse button on the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<void>}
   */
  mouseRelease(timeoutMs?: number | undefined | null): Promise<void>
  /**
   * (async) Get the containing application element of the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<?Element>} The application element, or null if not present.
   */
  application(timeoutMs?: number | undefined | null): Promise<Element | null>
  /**
   * (async) Get the containing window element of the first matching element.
   *
   * @param {number} [timeoutMs] - Timeout in milliseconds.
   * @returns {Promise<?Element>} The window element, or null if not present.
   */
  window(timeoutMs?: number | undefined | null): Promise<Element | null>
  /**
   * (async) Highlights the first matching element with a colored border.
   *
   * @param {number} [color] - Optional BGR color code (32-bit integer). Default: 0x0000FF (red)
   * @param {number} [durationMs] - Optional duration in milliseconds.
   * @param {number} [timeoutMs] - Optional timeout in milliseconds.
   * @returns {Promise<void>}
   */
  highlight(color?: number | undefined | null, durationMs?: number | undefined | null, timeoutMs?: number | undefined | null): Promise<void>
}
